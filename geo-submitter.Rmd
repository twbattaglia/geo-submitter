---
title: "GEO-submitter"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    source_code: embed
    theme: bootstrap
---

```{r setup, include=FALSE}
library(flexdashboard)
library(shiny)
source("util/helpers.R")
source("util/import_rcc.R")
options(shiny.maxRequestSize = 9*1024^2) # 9mb limit
tags$head(tags$script(src = "www/js/ga.js")) # google analystics
```


Introduction {data-orientation=columns}
=====================================  


Column {data-width=700}
-------------------------------------
    
### Introduction {data-height=250}
    
```{r introduction}
p('Currently there does not exist an easy-to-use interface for submitting array data to Gene Expression Omnibus (GEO), through NCBI. This difficulty can lead to the inability to properly submit studes and adhere to the', a('Minimum information about a microarray experiment (MAIME).', href = "http://www.ncbi.nlm.nih.gov/geo/info/MIAME.html"), 'GEO-submiter is meant to remedy this issue by creating a web-based tool to help researchers submit their gene expression array studies to GEO by using the, ', a("Simple Omnibus Format in Text (SOFT).", href = 'http://www.ncbi.nlm.nih.gov/geo/info/soft.html'), 'The SOFT file format allows a researcher to include all experiemental protocols, information and gene expression data in one file. After filling in all required information found within this tool, a SOFT text file will be generated, which can be submitted along with the raw data to GEO as a single submission.' )

tags$b("This is still a work-in-progress and a proof-of-concept, so do not use it for anything important!")

```

### Normalization methods 
    
```{r normalization methods}
p('GEO submission require the SOFT file to include normalized expression values for each of the genes for every sample within an array. GEO-submitter makes it easier to generate the normalized values using a multitude of R-packages. After importing the raw data, you can select the many different techniques for normalizing your microarray or nanostring data. Below is a breakdown of the different normalization techniques currently supported by GEO-submitter.')

h4("Microarray Normalization")
p("Robust Multi-array Average (RMA)", a("Paper", href = "http://www.ncbi.nlm.nih.gov/pubmed/12925520"))
p("(MAS5)", a("Paper", href = "http://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-8-273"))
p("(GCRMA)", a("Bioconductor", href = "https://www.bioconductor.org/packages/release/bioc/html/gcrma.html"))

tags$hr()

h4("Nanostring Normalization")
p("NanoStringNorm-Sum (housekeeping.sum)")
p("NanoStringNorm-Mean (housekeeping.geo.mean)")
```


Column {data-width=300}
-------------------------------------

    
### Credits & citations

```{r credits}
p("Below are a list of the packages and databases which were used or influenced the creation GEO-submitter. See the source code for a more detailed listing of the packages used.")
tags$hr()
h5("Shiny:", a("Github, ", href = 'https://github.com/rstudio/shiny'), a("Website", href = 'http://shiny.rstudio.com/'))
tags$hr()
h5("Flexdashboard:", a("Github, ", href = 'https://github.com/rstudio/flexdashboard'), a("Website", href = 'http://rmarkdown.rstudio.com/flexdashboard/index.html'))
tags$hr()
h5("NanoStringNorm:", a("Paper, ", href = 'http://www.ncbi.nlm.nih.gov/pubmed/22513995'), a("CRAN", href = 'https://cran.r-project.org/web/packages/NanoStringNorm/index.html'))
tags$hr()
h5("GEOsubmission:", a("Bioconductor", href = 'http://www.bioconductor.org/packages//release/bioc/html/GEOsubmission.html'))
tags$hr()
h5("highcharter:", a("Github", href = 'http://www.ncbi.nlm.nih.gov/pubmed/11726920'))
tags$hr()
h5("rhandsontable:", a("Github", href = 'https://github.com/jrowen/rhandsontable'))
tags$hr()
h5("GEO:", a("Website", href = 'http://www.ncbi.nlm.nih.gov/geo/'))
tags$hr()
h5("MAIME:", a("Paper", href = 'http://www.ncbi.nlm.nih.gov/pubmed/11726920'))
tags$hr()
h5("Bootstrap3:", a("Github", href = 'https://github.com/twbs/bootstrap'))
tags$hr()
h5("affy:", a("Bioconductor", href = 'https://bioconductor.org/packages/release/bioc/html/affy.html'))
tags$hr()
h5('Application author', a('Thomas W. Battaglia', href = 'https://github.com/twbattaglia'))

```



Upload {data-orientation=rows}
=====================================  

Inputs {.sidebar data-width=268}
-----------------------------------------------------------------------

```{r upload bar}
# Data Type
h4('Data Type')
selectizeInput(inputId = 'dataType', width = NULL,
               label = helpText("Select an array platform type."), 
               choices = c('Nanostring', "Microarray"), 
               options = list(placeholder = 'Select array type....     ', 
                              onInitialize = I('function() { this.setValue(""); }'))
               )
tags$hr()

# Input Files
h4('Upload Files')
fileInput(inputId = 'upload', 
          label = helpText("Use 'Shift' to select multiple files."), 
          multiple = T,
          accept = c(
            '.RCC',
            '.RCC.gz', 
            '.CEL',
            '.CEL.gz')
      )
tags$hr()

# Normalization method
conditionalPanel(condition = "input.dataType == 'Nanostring'",
                 h4('Normalization Method'),
                 selectInput(inputId = "normalizationNS", 
                             label = helpText("Select a normalization method"), 
                             choices = c("Housekeeping-Sum" = "housekeeping.sum",
                                         "Housekeeping-Mean" = "housekeeping.geo.mean"), 
                             selectize = T),
                 tags$hr()
)

conditionalPanel(condition = "input.dataType == 'Microarray'",
                 h4('Normalization Method'),
                 selectInput(inputId = "normalizationMA", 
                             label = helpText("Select normalization method."), 
                             choices = c("RMA" = "RMA",
                                         "MAS5" = "MAS5", 
                                         "GCRMA" = "GCRMA"), 
                             selectize = T),
                 tags$hr()
)
```

```{r data reactive}
# Reactive values to store imported data
data <- reactive({
  
  # Err if NULL
  if(is.null(input$upload)){
    return(NULL)
  }
  
  # Conditionals for data source type
  if(input$dataType == "Nanostring"){
    showNotification("Processing Nanostring...", type = "message")

    # Import RCC files and convert to table/metadata
    data <- import_rcc2(input$upload$datapath)
    
    # number of genes
    geneN <- nrow(data$x)
  
    # number the samples
    sampleN <- ncol(data$x)-3
  
    # sample ID's
    sampleID <- colnames(data$header)
    
    # un-normalized data for boxplot
    unnorm_boxplot <- subset(data$x, select = c(-1,-3)) %>% 
         reshape2::melt(id.vars = c("Name"), varnames = c("gene", "variable")) 
    
    # Normalized data (fix later with new normalization techniques)
    if(input$normalizationNS != "deseq2"){
      normalized <- NanoStringNorm(
        x = data$x,
        anno = NA,
        CodeCount = 'sum',
        Background = 'mean',
        SampleContent = input$normalizationNS,
        round.values = FALSE,
        take.log = FALSE,
        return.matrix.of.endogenous.probes = TRUE
      )
      
      # normalized data for boxplot
      norm_boxplot <- melt(normalized, id.vars = c("Name"), varnames = c("gene", "variable")) 
      
    }
    
    # Show progress message
    showNotification("Processing complete...", type = "message")
    
    # Return a list of genes and metadata
    return(
      list(
        sampleN = sampleN,
        sampleID = sampleID,
        geneN = geneN,
        normalized = normalized,
        unnorm_boxplot = unnorm_boxplot,
        norm_boxplot = norm_boxplot)
    )
    
  }else if(input$dataType == "Microarray"){
    showNotification("Processing Microarray..", type = "message")
    
    # Load data with affy package
    ab <- ReadAffy(filenames = input$upload$datapath, compress = T, sampleNames = input$upload$name)
    
    # Un normalized data for boxplot. Temporary speed fix. sample 10,000 from each sample
    unnorm_boxplot <- melt(pm(ab), varnames = c("gene", "variable")) %>%
      group_by(variable) %>%
      sample_n(10000)
    
    # sample N
    sampleN <- length(pData(ab)$sample)

    # SampleID
    sampleID <- row.names(pData(ab))

    # Normalize based on 
    if (input$normalizationMA == "RMA"){
      showNotification("Normalizing Data. Please wait...", type = "warning", duration = 20)
      normalized <- rma(ab)
      geneN <- nrow(normalized@featureData@data)
      norm_boxplot <- melt(exprs(normalized), id.vars = c("Name"), varnames = c("gene", "variable")) 

    } else if (input$normalizationMA == "MAS5"){
      showNotification("Normalizing Data. Please wait...", type = "warning", duration = 15)
      normalized <- mas5(ab)
      geneN <- nrow(normalized@featureData@data)
      norm_boxplot <- melt(exprs(normalized), id.vars = c("Name"), varnames = c("gene", "variable")) 

    } else if (input$normalizationMA == "GCRMA"){
      showNotification("Normalizing Data. Please wait...", type = "warning", duration = 15)
      normalized <- gcrma(ab)
      geneN <- nrow(normalized@featureData@data)
      norm_boxplot <- melt(exprs(normalized), id.vars = c("Name"), varnames = c("gene", "variable")) 

    } else{
      showNotification("Error processing data...", type = "error")
      return()
    }
    
    # Show progress message
    showNotification("Processing complete...", type = "message")
    
    # Return a list of genes and metadata
    return(
      list(
        sampleN = sampleN,
        sampleID = sampleID,
        geneN = geneN,
        normalized = exprs(normalized),
        unnorm_boxplot = unnorm_boxplot,
        norm_boxplot = norm_boxplot)
    )
    
  } # end of microarray
  
})
```


Row
-----------------------------------------------------------------------

### Number of genes

```{r valuebox geneN}
output$geneNumber <- renderValueBox({
  
  # Err if NULL
  if(is.null(data())){
    return(valueBox(0, caption = "Number of genes", icon = "fa-cubes"))
  }
  valueBox(data()$geneN, caption = "Number of genes", icon = "fa-cubes")
})
valueBoxOutput(outputId = "geneNumber")
```

### Number of samples

```{r valuebox sampleN}
output$sampleNumber <- renderValueBox({
  
  # Err if NULL
  if(is.null(data()$sampleN)){
    return(valueBox(0, caption = "Number of samples", icon = "fa-users"))
  }
  
  valueBox(data()$sampleN, caption = "Number of samples", icon = "fa-users")
})
valueBoxOutput(outputId = "sampleNumber")
```


Row 
-------------------------------------
   
###  

```{r raw_boxplot}
output$unnormalized <- renderHighchart({
  
  # Err if NULL
  if(is.null(data()$unnorm_boxplot)){
    return(NULL)
  }
  
  # Convert to long format for high charts
  showNotification("Plotting raw values...", type = "message")
  
  # Plot boxplot over gene abundance values
  highchart() %>% 
    hc_add_series_boxplot(x = log(data()$unnorm_boxplot$value), 
                          by = data()$unnorm_boxplot$variable,
                          color = "#2980b9")  %>%
    hc_title(text = "Raw Expression Values") %>%
    hc_legend(enabled = FALSE) %>%
    hc_yAxis(title = list(text = "Log10 gene abundances"))
})
highchartOutput("unnormalized")
``` 

###  

```{r norm_boxplot}
output$normalized <- renderHighchart({
  
  # Err if NULL
  if(is.null(data()$norm_boxplot)){
    return(NULL)
  }
  
  # Convert to long format for high charts
  showNotification("Plotting normalized values...", type = "message")
  
  # Plot boxplot over gene abundance values
  highchart() %>% 
    hc_add_series_boxplot(x = log(data()$norm_boxplot$value), 
                          by = data()$norm_boxplot$variable,
                          color = "#2980b9")  %>%
    hc_title(text = "Normalized Expression Values") %>%
    hc_legend(enabled = FALSE) %>%
    hc_yAxis(title = list(text = "Log10 gene abundances"))
})
highchartOutput("normalized")
``` 


Experimental setup
===================================== 

Inputs {.sidebar data-width=268}
-----------------------------------------------------------------------

```{r save experiment}
h4("Help")
p("This section is the heart of", tags$b('GEO-submitter '), "and should be filled completely and as detailed as possible. The information stored here is meant for researchers to understand the experimental design, as well as the platform and protocols used throughout the study.")
  
p("The best way to write detailed protocols and experimental metadata, is to view studies similar to your own. Search", a("GEO DataSets", href = "http://www.ncbi.nlm.nih.gov/gds"), " for submitted and curated studies. It is also useful to query studies with the same platform identifer, so you can re-use the protocols for labeling, hybridization, etc..")

p("When you have filled out the entries completly, save the information using the button below.")

# Save experiemental information
actionButton(inputId = "saveExp", icon = icon("floppy-o"), label = "Save", width = "215px")

# Store all reactive data assocaited with Series information
reactive <- reactiveValues()

# On save, add values to appropriate sections
observeEvent(input$saveExp, {
  showNotification("Saving data...", type = "message")
  
  # TODO validations
  reactive$name <- isolate(input$name)
  reactive$title <- isolate(input$title)
  reactive$summary <- isolate(input$summary)
  reactive$design <- isolate(input$design)
  
  reactive$organism <- isolate(input$organism)
  reactive$molecule <- isolate(input$molecule)
  reactive$source_type <- isolate(input$source_type)
  reactive$platform <- isolate(input$platform)
  reactive$pubmed <- isolate(input$pubmed)
  reactive$label <- isolate(input$label)

  reactive$extraction <- isolate(input$extraction)
  reactive$labeling <- isolate(input$labeling)
  reactive$hybridization <- isolate(input$hybridization)
  reactive$scanning <- isolate(input$scanning)
  reactive$data_processing <- isolate(input$data_processing)

  # Add sampleN for easier looping
  if(is.null(data())){
    reactive$sampleN <- 0
  } else{
    reactive$sampleN <- isolate(data()$sampleN)
  }
  
})

```


Column {.tabset .tabset-fade}
-------------------------------------

### Experimental 
    
```{r experimental}
h4("Name")
textInput(inputId = "name", 
          label = "Provide an identifier for this entity. This identifier is used only as an internal reference within a given file. The identifier will not appear on final GEO records.", 
          width = "400px",
          value = "", 
          placeholder = "Enter text...")

tags$hr()

h4("Title")
textInput(inputId = "title", 
          label = "Provide a unique title that describes the overall study. Max 255 characters.", 
          value = "", 
          width = "400px",
          placeholder = "Enter text...")

tags$hr()

h4("Summary")
textareaInput(inputId = "summary", 
          label = "Summarize the goals and objectives of this study. The abstract from the associated publication may be suitable. You can include as much text as you need to thoroughly describe the study.", 
          value = "", 
          placeholder = "Enter text...")

tags$hr()

h4("Design")
textareaInput(inputId = "design", 
          label = "Provide a description of the experimental design. Indicate how many Samples are analyzed, if replicates are included, are there control and/or reference samples. etc..", 
          value = "", 
          placeholder = "Enter text...")
```
   
### Platform 

```{r platform}
h4("Organism")
textInput(inputId = "organism", 
          label = p("Identify the organism(s) from which the biological material was derived. See", a("NCBI Taxonomy", href="http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/"), " for a listing."),
          value = "",
          width = "400px",
          placeholder = "Mus musculus")

tags$hr()

h4("Molecule Type")
selectInput(inputId = 'molecule', 
            label = 'Specify the type of molecule that was extracted from the biological material.', 
            choices = c("total RNA", "polyA RNA", "cytoplasmic RNA", "nuclear RNA", "genomic DNA", "protein", "other"),
            width = "400px",
            selectize = TRUE)

tags$hr()

h4("Sample Source")
textInput(inputId = "source_type", 
          label = "Select the sample source type.", 
          value = "", 
          width = "400px",
          placeholder = "Terminal Ileum")

tags$hr()

h4("Platform")
textInput(inputId = "platform", 
          label = p("Enter the NCBI platform identifier used.", a("See", href = "http://www.ncbi.nlm.nih.gov/geo/browse/?view=platforms&tool=findplatform"), "to find the corresponding identifier."), 
          value = "", 
          width = "400px",
          placeholder = "GPL19964")

tags$hr()

h4("Label Type")
textInput(inputId = "label", 
          label = "Specify the compound used to label the extract e.g., biotin, Cy3, Cy5, 33P.", 
          value = "", 
          width = "400px",
          placeholder = "biotin")

tags$hr()

h4("Pubmed ID (Optional)")
textInput(inputId = "pubmed", 
          label = "Optionally, specify a valid PubMed identifier (PMID) that references a published article describing this study. Most commonly, this information is not available at the time of submission - it can be added later once the data are published.", 
          value = "", 
          width = "400px",
          placeholder = "12345678")
```     


### Protocols 

```{r protocols}
h4("Extraction Protocol")
textareaInput(inputId = "extraction", 
              label = "Describe the protocol used to isolate the extract material. You can include as much text as you need to thoroughly describe the protocol.", 
              value = "", 
              placeholder = "TRIzol (Invitrogen) followed by RNeasy column cleanup (Qiagen) using the manufacturers protocols.")
tags$hr()

h4("Labeling Protocol")
textareaInput(inputId = "labeling", 
              label = "Describe the protocol used to label the extract. You can include as much text as you need to thoroughly describe the protocol.", 
              value = "", 
              placeholder = "Labeled according to the manufacturer's protocol. The probe pair consists of a Reporter Probe, which carries the signal on its 5' end, and a Capture Probe which carries a biotin on
the 3' end. The color codes carry six positions and each position can be one of four colors, thus allowing for a large diversity of tags that can be mixed together in a single well for direct hybridization to target and yet still be individually resolved and identified during data collection. http://www.nanostring.com/media/pdf/MAN_nCounter_Gene_Expression_Assay.pdf")
tags$hr()

h4("Hybridization Protocol")
textareaInput(inputId = "hybridization", 
              label = "Describe the protocols used for hybridization, blocking and washing, and any post-processing steps such as staining.", 
              value = "", 
              placeholder = "Hydridized according to the manufacturer's protocol. the hybridization mixture is allowed to bind to the magnetic beads by the Capture Probe. Wash steps are performed and excess Reporter Probes and non-target cellular transcripts are removed during wash steps. After washing, the Capture Probes and Target/Probe complexes are eluted off of the beads and are hybridized to magnetic beads complementary to the Reporter Probe. Wash steps
are performed and excess Capture Probes are washed away. Finally, the purified Target/Probe complexes are eluted off and are immobilized in the cartridge for data collection. http://www.nanostring.com/media/pdf/MAN_nCounter_Gene_Expression_Assay.pdf")
tags$hr()

h4("Scanning Protocol")
textareaInput(inputId = "scanning", 
              label = "Describe the scanning and image acquisition protocols, hardware, and software. You can include as much text as you need to thoroughly describe the protocol.", 
              value = "", 
              placeholder = "Scanned according to the manufacturer's protocol. Data Collection is carried out in the nCounter? Digital Analyzer. At the highest standard data resolution, 555_1155 fields of view (FOV) are collected per flow cell using a microscope objective and a CCD camera yielding data of hundreds of thousands of target molecule counts. Digital images are processed on the nCounter Digital Analyzer and the barcode counts are tabulated in a comma separated value (CSV) format. (http://www.nanostring.com/media/pdf/MAN_nCounter_Gene_Expression_Assay.pdf)")
tags$hr()

h4("Data Processing Protocol")
textareaInput(inputId = "data_processing", 
              label = "Provide details of how data in the VALUE column of your table were generated and calculated, i.e., normalization method, data selection procedures and parameters, transformation algorithm (e.g., MAS5.0), and scaling parameters. You can include as much text as you need to thoroughly describe the processing procedures.", 
              value = "", 
              placeholder = "Probe set summarization and normalization was performed by Probe-level background correction using the R/Bioconductor package NanoStringNorm.")
```


### Authors
    
```{r author input}
fluidRow(
    column(width = 4, 
           textInput(inputId = "firstName", 
                     label = h5("First Name"), 
                     value = "", 
                     placeholder = "Watson")),
    column(width = 4, 
           textInput(inputId = "middleInitial", 
                     label = h5("Middle Initial (optional)"), 
                     value = "", 
                     placeholder = "N")),
    column(width = 4, 
           textInput(inputId = "lastName", 
                     label = h5("Last Name"), 
                     value = "", 
                     placeholder = "Crick"),
           actionButton(inputId = "addAuthor", label = "Add Author", icon = icon("fa-list"))
           #actionButton(inputId = "editAuthor", label = "Edit Author List", icon = icon("fa-list"))
           )
    )
tags$hr()
```   


```{r author reactive}
# Set a reactive dataframe to show a table of authors
reactive$authorDF <- data.frame(First = character(),
                                Middle = character(),
                                Last = character())

# Observe if 'add author' button is pressed
observeEvent(input$addAuthor, {
  
  # Require first and last names
  if(input$firstName == "" | input$lastName == ""){
    showNotification("Error Adding Author...", type = "error")
  }
  
  # Require first and last names
  req(input$firstName)
  req(input$lastName)
  
  # Concatenate names together (for internal use)
  new_author <- isolate(
    paste(input$firstName, input$middleInitial, input$lastName, sep = ",") %>% 
      gsub(pattern = ",,", replacement = ",", x = ., fixed = T) %>%  # fix no middle initials
      gsub(pattern = ".", replacement = "", x = ., fixed = T) # fix dots in middle initials
  )
  
  # Add authors as a reactive list
  reactive$authorList <- c(isolate(reactive$authorList), new_author)
  
  # Add values to table
  showNotification("Adding Author...", type = "message")
  author_newLine <- isolate(c(input$firstName, input$middleInitial, input$lastName))
  isolate(reactive$authorDF <- rbind(as.matrix(reactive$authorDF), unlist(author_newLine)))
})

# Render table of authors
output$author_table <- renderTable({reactive$authorDF}, include.rownames = F)
tableOutput("author_table")
```


```{r author modal}
observeEvent(input$editAuthor, {
  showModal(modalDialog(
    title = "Edit Authors",
    h4("Select the authors you wish to remove. (TODO)"),
    renderUI({
      lapply(reactive$authorList, function(x){
        id <- gsub(pattern = ",", replacement = "_", x = x, fixed = T)
        checkboxInput(inputId = id, label = tags$b(x), value = FALSE)
      })
    }),
    actionButton(inputId = "authorRemove", label = "Remove Authors", icon = icon("fa-trash")),
    easyClose = TRUE,
    footer = NULL
  ))
})

# Remove any authors in the checklist
observeEvent(input$authorRemove, {
  
  # Iterate over each input. checkbox label will be in input$AUTHOR
  sapply(reactive$authorList, function(x){
    
    # Convert to same format as input checkbox labels so it can be found.
    id <- gsub(pattern = ",", replacement = "_", x = x, fixed = T)
    
    # If checked boxes are (TRUE), then remove them from the list of authors.
    if(input[[id]]){
      
      # Remove any entries from the author dataframe
      # - split the entry into pieces to match to the dataframe and subset based on those pieces
      split <- strsplit(x, ",", fixed = T)
      
      # Fix for if middle initial is missing
      if(length(split[[1]]) == 2){
        split[[1]][3] = split[[1]][2]
        split[[1]][2] = ""
      } 
      
      # Subset based on first, middle and last names that match
      authorTable <- as.data.frame(reactive$authorDF)
      authorTableSub <- subset(authorTable, First != as.character(split[[1]][1]) & Middle != as.character(split[[1]][3]) & Last != as.character(split[[1]][3]))
      isolate(reactive$authorDF <- authorTableSub)


      # Remove any entries from the reactive authors list
      reactive$authorList <- isolate(reactive$authorList[!reactive$authorList %in% x])
      #message(paste0("removed ", x, " from reactive list."))
    }
  })
  
})

```



Sample data
=====================================

Inputs {.sidebar data-width=268}
-----------------------------------------------------------------------

```{r save sample}
h4("Help")
p("This section is meant to give important information about each sample. Choose multiple inputs from the selection box, or type out you own if it is not listed. If information is not available for a particular sample, enter ", tags$b('Not applicable. '))
p("When you have filled out the entries completly, save the information using the button below.")


# Save sample information
actionButton(inputId = "saveSample", icon = icon("floppy-o"), label = "Save", width = "215px")
observeEvent(input$saveSample, {
  showNotification("Saving data...", type = "message")
})
```


Column {data-width=300}
-------------------------------------
    
### Selection
    
```{r sample characteristic}
h4("Choose characteristics")
selectizeInput(inputId = "sampleChar", 
               label = helpText("Select or enter the variables which best describe your samples."), 
            choices = c("dose", "time", "tissue", "strain", "gender", "cell line", "development stage", "age", "agent", "cell type", "infection", "isolate", "metabolism", "shock", "stress", "temperature", "specimen", "disease state", "protocol", "growth protocol", "genotype/variation", "species", "individual"), 
            options = list(create = TRUE, placeholder = 'Select variables...     '),
            multiple = TRUE)
```


Column 
-------------------------------------
    
### Characteristics Table
    
```{r sample select}
output$hot = renderRHandsontable({
  
  # Err if null
  if(is.null(data())){
    return()
  }
  
  # Get number of sample
  N <- as.integer(data()$sampleN)
  
  # Create new table with row.names as sampe id's
  df <- data.frame(ID = row.names(input$upload), 
                   Sample = data()$sampleID, 
                   Description = character(N))
  
  # aggregate columns
  cols <- input$sampleChar
  
  # Dynamticlaly add new columns to df
  for(i in cols){
    df[i] <- character(N)
  }
  
  # Generate handsome table
  rht <- rhandsontable(df, stretchH = "all", rowHeaders = NULL) %>%
    hot_col("Sample", readOnly = TRUE, copyable = T) %>%
    hot_col("ID", readOnly = TRUE, copyable = T) %>%
    hot_col("Description", type = "autocomplete", copyable = T) %>%
    hot_context_menu(allowRowEdit = FALSE, allowColEdit = FALSE)
  
  # Make all colums factorable
  for(i in cols){
    rht <- rht %>%
      hot_col(i, "autocomplete", copyable = T, highlightRow = F, strict = T, default = "Not applicable")
  }
  
  # Return table
  rht
  
})

# Output Hot table
fillCol(rHandsontableOutput("hot"))
```



Review & Export
=====================================

Inputs {.sidebar data-width=267}
-----------------------------------------------------------------------
```{r help export}
h4("Help")
p("Once you have filled out all the experimental and sample information, you can export your data as a SOFT file. Review the", tags$b("Experimental data"), "and", tags$b("Sample data"), "tables to be sure the information you have inputed is correct. Once the data is correct, select the export file option on the right hand-side.")
```

   
Column {.tabset .tabset-fade data-width=700}
-------------------------------------
   
### Experimental data

```{r experiment review}
output$expReview <- renderTable(hover = T, 
                                rownames = F, {
  
  x <- reactiveValuesToList(reactive)
  x$authorDF <- NULL
  df <- t(as.data.frame(x))
  data.frame(Variable = row.names(df), Values = df[,1])
})
tableOutput('expReview')
```   
 
### Sample data
```{r sample review}
output$sampleReview <- renderTable(hover = T, {
  
  # Err if null
  if(is.null(data())){
    return()
  }
  hot_to_r(input$hot)
  }, 
  include.rownames = F)

tableOutput('sampleReview')
```



Column {data-width=300}
-------------------------------------
    
### Export SOFT File
Once the experimental and sample metadata are valid, export all information as a SOFT file. This SOFT file will be required for data submission on GEO's SOFT submission website.

```{r export}
downloadLink('downloadData', 'Export SOFT file')
output$downloadData <- downloadHandler(
  contentType = "text/txt",
  filename = "soft.txt",
  content = function(file) {
    
    # Write series information
    write_append(paste0("^SERIES = ", isolate(reactive$name)), filename = file)
    write_append(paste0("!Series_title = ", isolate(reactive$title)), filename = file)
    write_append(paste0("!Series_summary = ", isolate(reactive$summary)), filename = file)
    write_append(paste0("!Series_overall_design = ", isolate(reactive$design)), filename = file)

    # Loop over each number of samples
    for(i in 1:isolate(reactive$sampleN)){
      write_append(paste0("!Series_sample_id = ", as.character(i)), filename = file)
    }
    
    # Loop over each of the authors
    for(i in isolate(reactive$authorList)){
      write_append(paste0("!Series_contributor = ", i), filename = file)
    }
    
    # Write Optionals
    if(isolate(reactive$pubmed) != ""){
      write_append(paste0("!Series_pubmed_id", " = ", isolate(reactive$pubmed)), filename = file)
    }
    
    # Sample information
    sampleInfo <- hot_to_r(input$hot)
    #sampleInfo <- sampleInfo[!is.null(sampleInfo$SampleID), ] # Temporary fix to remove NA rows (Issue #2)
    for (i in 1:nrow(sampleInfo)){
      # Write ^SAMPLE
      write_append(paste0("^SAMPLE", " = ", sampleInfo$ID[i]), filename = file)
      
      # Write !Sample_title
      write_append(paste0("!Sample_title", " = ", sampleInfo$Sample[i]), filename = file)
      
      # Write !Sample_supplementary_file
      write_append(paste0("!Sample_supplementary_file", " = ", input$upload$name[i]), filename = file)
      
      # Write !Sample_supplementary_file
      sub <- sampleInfo[i, c(-1:-3)]
      sapply(colnames(sub), function(x) {
         write_append(paste0("!Sample_characteristics_ch1", " = ", x, " : ", sub[ ,x]), filename = file)
      })
      
      # Write !Sample_Description
      write_append(paste0("!Sample_Description", " = ", sampleInfo$Description[i]), filename = file)
      
      # Write !Sample_source_name
      write_append(paste0("!Sample_source_name", " = ", isolate(reactive$source_type)), filename = file)
      
      # Write !Sample_organism
      write_append(paste0("!Sample_organism", " = ", isolate(reactive$organism)), filename = file)

      # Write !Sample_label
      write_append(paste0("!Sample_label", " = ", isolate(reactive$label)), filename = file)
      
      # Write !Sample_molecule
      write_append(paste0("!Sample_molecule", " = ", isolate(reactive$molecule)), filename = file)
      
      # Write !Sample_extract_protocol
      write_append(paste0("!Sample_extract_protocol", " = ", isolate(reactive$extraction)), filename = file)
      
      # Write !Sample_label_protocol
      write_append(paste0("!Sample_label_protocol", " = ", isolate(reactive$labeling)), filename = file)
      
      # Write !Sample_hyb_protocol
      write_append(paste0("!Sample_hyb_protocol", " = ", isolate(reactive$hybridization)), filename = file)
      
      # Write !Sample_scan_protocol
      write_append(paste0("!Sample_scan_protocol", " = ", isolate(reactive$scanning)), filename = file)
      
      # Write !Sample_data_processing
      write_append(paste0("!Sample_data_processing", " = ", isolate(reactive$data_processing)), filename = file)
      
      # Subset the expression values
      normalized_sub <- subset(data()$normalized, select = i)
      
      # Iterate over each row and write the expression values
      write_append("#ID_REF =", filename = file)
      write_append(paste0("#VALUE = ", "Normalized expression counts"), filename = file)
      write_append("!Sample_table_begin", filename = file)
      write_append(paste("ID_REF", "VALUE", sep = "\t"), filename = file)
      write.table(as.matrix(normalized_sub), 
                  file = file, 
                  append = TRUE, 
                  quote = FALSE, 
                  row.names = TRUE, 
                  col.names = FALSE, 
                  sep = "\t")
      write_append("!Sample_table_end", filename = file)
    }
})
```





<style>
#sidebar.section.sidebar {
  background-color: white; 
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif !important;
}

.js-irs-0 .irs-bar {
border-top-color: #d01010;
border-bottom-color: #d01010;
} 

.js-irs-0 .irs-bar-edge {
border-color: #d01010;
}

.js-irs-0 .irs-single, .js-irs-0 .irs-bar-edge, .js-irs-0 .irs-bar {
background: #a00;
}

</style>



